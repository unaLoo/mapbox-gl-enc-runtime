<!doctype html>
<html>
	<head>
		<meta charset="utf-8" />
		<title>TinySDF Testing</title>
		<style>
			canvas {
				border: 1px solid #444;
				background: #000;
				display: block;
				margin: 20px;
			}
		</style>
	</head>
	<body>
		<canvas id="glCanvas" width="800" height="500"></canvas>

		<script type="module">
			/**
             const tinySdf = new TinySDF({
                fontSize: 24,             // Font size in pixels
                fontFamily: 'sans-serif', // CSS font-family
                fontWeight: 'normal',     // CSS font-weight
                fontStyle: 'normal',      // CSS font-style
                buffer: 3,                // Whitespace buffer around a glyph in pixels
                radius: 8,                // How many pixels around the glyph shape to use for encoding distance
                cutoff: 0.25              // How much of the radius (relative) is used for the inside part of the glyph
            });

            const glyph = tinySdf.draw('泽'); // draw a single character
            */

			import TinySDF from 'https://cdn.skypack.dev/@mapbox/tiny-sdf'

			console.log(TinySDF)

			const tinySdf = new TinySDF({
				fontSize: 36,
				fontFamily: '"Microsoft YaHei", "PingFang SC", sans-serif',
				buffer: 4,
				radius: 12,
				cutoff: 0.25,
			})

			const canvas = document.getElementById('glCanvas')
			const gl = canvas.getContext('webgl2')
			if (!gl) {
				alert('WebGL2 not supported')
				throw new Error('WebGL2 not supported')
			}

			const vsSource = `#version 300 es
			      in vec2 a_position;
			      in vec2 a_texCoord;
			      uniform vec2 u_offset;
			      uniform vec2 u_scale;
			      out vec2 v_texCoord;
			      void main() {
			        vec2 pos = (a_position * u_scale) + u_offset;
			        gl_Position = vec4(pos, 0.0, 1.0);
			        v_texCoord = a_texCoord;
			      }`

			const fsSource = `#version 300 es
			      precision highp float;
			      in vec2 v_texCoord;
			      uniform sampler2D u_sdfTexture;
			      uniform vec4 u_color;
			      out vec4 fragColor;

			      void main() {
			        float dist = texture(u_sdfTexture, v_texCoord).r;
			        // SDF 渲染：平滑边缘
			        float alpha = smoothstep(0.65, 0.85, dist);
			        if (alpha < 0.01) discard; // 透明区域跳过
			        fragColor = vec4(u_color.rgb, u_color.a * alpha);
			      }`

			// 编译着色器
			function createShader(gl, type, source) {
				const shader = gl.createShader(type)
				gl.shaderSource(shader, source)
				gl.compileShader(shader)
				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
					console.error('Shader compile error:', gl.getShaderInfoLog(shader))
					gl.deleteShader(shader)
					return null
				}
				return shader
			}

			const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource)
			const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource)

			const program = gl.createProgram()
			gl.attachShader(program, vertexShader)
			gl.attachShader(program, fragmentShader)
			gl.linkProgram(program)
			if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
				console.error('Program link error:', gl.getProgramInfoLog(program))
			}

			// 获取 attribute / uniform 位置
			const a_position = gl.getAttribLocation(program, 'a_position')
			const a_texCoord = gl.getAttribLocation(program, 'a_texCoord')
			const u_offset = gl.getUniformLocation(program, 'u_offset')
			const u_scale = gl.getUniformLocation(program, 'u_scale')
			const u_sdfTexture = gl.getUniformLocation(program, 'u_sdfTexture')
			const u_color = gl.getUniformLocation(program, 'u_color')

			// 启用程序
			gl.useProgram(program)

			// Quad 顶点（归一化设备坐标，-1 到 1）
			const quadVertices = new Float32Array([-1, -1, 0, 1, 1, -1, 1, 1, -1, 1, 0, 0, 1, 1, 1, 0])
			const vertexBuffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, quadVertices, gl.STATIC_DRAW)

			// ---------- 4. 生成并上传 SDF 纹理 ----------
			function createSDFTexture(char) {
				const { data, width, height } = tinySdf.draw(char)

				const texture = gl.createTexture()
				gl.bindTexture(gl.TEXTURE_2D, texture)
				// 使用 R8 格式（单通道）
				gl.texImage2D(
					gl.TEXTURE_2D,
					0,
					gl.R8, // 内部格式
					width,
					height,
					0,
					gl.RED, // 源格式
					gl.UNSIGNED_BYTE,
					data,
				)

				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)

				return { texture, width, height }
			}

			function renderChar(char, x, y, color) {
				const { texture, width, height } = createSDFTexture(char)

				// 计算字符在 NDC（-1~1）中的位置和缩放
				const canvasAspect = canvas.width / canvas.height
				const charWidthNDC = (width / canvas.width) * 2
				const charHeightNDC = (height / canvas.height) * 2

				const offsetX = (x / canvas.width) * 2 - 1 + charWidthNDC / 2
				const offsetY = 1 - (y / canvas.height) * 2 - charHeightNDC / 2

				// 绑定纹理
				gl.activeTexture(gl.TEXTURE0)
				gl.bindTexture(gl.TEXTURE_2D, texture)
				gl.uniform1i(u_sdfTexture, 0)

				// 设置 uniform
				gl.uniform2f(u_offset, offsetX, offsetY)
				gl.uniform2f(u_scale, charWidthNDC, charHeightNDC)
				gl.uniform4f(u_color, color[0], color[1], color[2], color[3])

				// 设置顶点属性
				gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)
				gl.enableVertexAttribArray(a_position)
				gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 16, 0)
				gl.enableVertexAttribArray(a_texCoord)
				gl.vertexAttribPointer(a_texCoord, 2, gl.FLOAT, false, 16, 8)

				// 绘制
				gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)

				gl.deleteTexture(texture)
			}

			function renderText() {
				gl.clearColor(0.0, 0.0, 0.0, 1.0)
				gl.clear(gl.COLOR_BUFFER_BIT)

				let x = 40 // 起始 x 像素
				const y = 60 // y 基线
				const color = [0, 1, 1, 1] // 青色 (RGBA)

				renderChar('你', x, y, color)
				x += 180 // 简单 advance（实际应从 metrics 获取）

				renderChar('好', x, y, color)
			}

			// 执行渲染
			renderText()
		</script>
	</body>
</html>
